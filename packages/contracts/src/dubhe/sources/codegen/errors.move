  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module dubhe::errors {

  #[error]

  const ASSET_NOT_FOUND: vector<u8> = b"Asset not found";

  public fun asset_not_found_error(condition: bool) {
    assert!(condition, ASSET_NOT_FOUND)
  }

  #[error]

  const ASSET_ALREADY_FROZEN: vector<u8> = b"Asset already frozen";

  public fun asset_already_frozen_error(condition: bool) {
    assert!(condition, ASSET_ALREADY_FROZEN)
  }

  #[error]

  const INVALID_SENDER: vector<u8> = b"Invalid sender";

  public fun invalid_sender_error(condition: bool) {
    assert!(condition, INVALID_SENDER)
  }

  #[error]

  const INVALID_RECEIVER: vector<u8> = b"Invalid receiver";

  public fun invalid_receiver_error(condition: bool) {
    assert!(condition, INVALID_RECEIVER)
  }

  #[error]

  const INVALID_METADATA: vector<u8> = b"Invalid metadata";

  public fun invalid_metadata_error(condition: bool) {
    assert!(condition, INVALID_METADATA)
  }

  #[error]

  const ACCOUNT_NOT_FOUND: vector<u8> = b"Account not found";

  public fun account_not_found_error(condition: bool) {
    assert!(condition, ACCOUNT_NOT_FOUND)
  }

  #[error]

  const ACCOUNT_BLOCKED: vector<u8> = b"Account is blocked";

  public fun account_blocked_error(condition: bool) {
    assert!(condition, ACCOUNT_BLOCKED)
  }

  #[error]

  const ACCOUNT_FROZEN: vector<u8> = b"Account is frozen";

  public fun account_frozen_error(condition: bool) {
    assert!(condition, ACCOUNT_FROZEN)
  }

  #[error]

  const BALANCE_TOO_LOW: vector<u8> = b"Balance too low";

  public fun balance_too_low_error(condition: bool) {
    assert!(condition, BALANCE_TOO_LOW)
  }

  #[error]

  const OVERFLOWS: vector<u8> = b"Operation overflows";

  public fun overflows_error(condition: bool) {
    assert!(condition, OVERFLOWS)
  }

  #[error]

  const NO_PERMISSION: vector<u8> = b"No permission";

  public fun no_permission_error(condition: bool) {
    assert!(condition, NO_PERMISSION)
  }

  #[error]

  const NOT_MINTABLE: vector<u8> = b"Asset is not mintable";

  public fun not_mintable_error(condition: bool) {
    assert!(condition, NOT_MINTABLE)
  }

  #[error]

  const NOT_BURNABLE: vector<u8> = b"Asset is not burnable";

  public fun not_burnable_error(condition: bool) {
    assert!(condition, NOT_BURNABLE)
  }

  #[error]

  const NOT_FREEZABLE: vector<u8> = b"Asset is not freezable";

  public fun not_freezable_error(condition: bool) {
    assert!(condition, NOT_FREEZABLE)
  }

  #[error]

  const BELOW_MIN_AMOUNT: vector<u8> = b"Amount is below minimum";

  public fun below_min_amount_error(condition: bool) {
    assert!(condition, BELOW_MIN_AMOUNT)
  }

  #[error]

  const LIQUIDITY_CANNOT_BE_ZERO: vector<u8> = b"Liquidity cannot be 0";

  public fun liquidity_cannot_be_zero_error(condition: bool) {
    assert!(condition, LIQUIDITY_CANNOT_BE_ZERO)
  }

  #[error]

  const MORE_THAN_MAX_SWAP_PATH_LEN: vector<u8> = b"More than Max";

  public fun more_than_max_swap_path_len_error(condition: bool) {
    assert!(condition, MORE_THAN_MAX_SWAP_PATH_LEN)
  }

  #[error]

  const MORE_THAN_RESERVE: vector<u8> = b"More than reserve";

  public fun more_than_reserve_error(condition: bool) {
    assert!(condition, MORE_THAN_RESERVE)
  }

  #[error]

  const SWAP_PATH_TOO_SMALL: vector<u8> = b"Swap path too small";

  public fun swap_path_too_small_error(condition: bool) {
    assert!(condition, SWAP_PATH_TOO_SMALL)
  }

  #[error]

  const RESERVES_CANNOT_BE_ZERO: vector<u8> = b"Reserve cannot be 0";

  public fun reserves_cannot_be_zero_error(condition: bool) {
    assert!(condition, RESERVES_CANNOT_BE_ZERO)
  }

  #[error]

  const AMOUNT_CANNOT_BE_ZERO: vector<u8> = b"Amount cannot be 0";

  public fun amount_cannot_be_zero_error(condition: bool) {
    assert!(condition, AMOUNT_CANNOT_BE_ZERO)
  }

  #[error]

  const LESS_THAN_AMOUNT_OUT_MIN: vector<u8> = b"Less than expected";

  public fun less_than_amount_out_min_error(condition: bool) {
    assert!(condition, LESS_THAN_AMOUNT_OUT_MIN)
  }

  #[error]

  const MORE_THAN_AMOUNT_IN_MAX: vector<u8> = b"More than expected";

  public fun more_than_amount_in_max_error(condition: bool) {
    assert!(condition, MORE_THAN_AMOUNT_IN_MAX)
  }

  #[error]

  const BRIDGE_NOT_OPENED: vector<u8> = b"Bridge is not opened";

  public fun bridge_not_opened_error(condition: bool) {
    assert!(condition, BRIDGE_NOT_OPENED)
  }

  #[error]

  const NOT_LATEST_VERSION: vector<u8> = b"Not latest version";

  public fun not_latest_version_error(condition: bool) {
    assert!(condition, NOT_LATEST_VERSION)
  }

  #[error]

  const DAPP_ALREADY_PAUSED: vector<u8> = b"Dapp already paused";

  public fun dapp_already_paused_error(condition: bool) {
    assert!(condition, DAPP_ALREADY_PAUSED)
  }

  #[error]

  const INVALID_PACKAGE_ID: vector<u8> = b"Invalid package id";

  public fun invalid_package_id_error(condition: bool) {
    assert!(condition, INVALID_PACKAGE_ID)
  }

  #[error]

  const INVALID_VERSION: vector<u8> = b"Invalid version";

  public fun invalid_version_error(condition: bool) {
    assert!(condition, INVALID_VERSION)
  }

  #[error]

  const DAPP_NOT_INITIALIZED: vector<u8> = b"Dapp not initialized";

  public fun dapp_not_initialized_error(condition: bool) {
    assert!(condition, DAPP_NOT_INITIALIZED)
  }

  #[error]

  const DAPP_ALREADY_INITIALIZED: vector<u8> = b"Dapp already initialized";

  public fun dapp_already_initialized_error(condition: bool) {
    assert!(condition, DAPP_ALREADY_INITIALIZED)
  }

  #[error]

  const INSUFFICIENT_CREDIT: vector<u8> = b"Insufficient credit";

  public fun insufficient_credit_error(condition: bool) {
    assert!(condition, INSUFFICIENT_CREDIT)
  }

  #[error]

  const DAPP_NOT_BEEN_DELEGATED: vector<u8> = b"Dapp not been delegated";

  public fun dapp_not_been_delegated_error(condition: bool) {
    assert!(condition, DAPP_NOT_BEEN_DELEGATED)
  }

  #[error]

  const DAPP_ALREADY_DELEGATED: vector<u8> = b"Dapp already delegated";

  public fun dapp_already_delegated_error(condition: bool) {
    assert!(condition, DAPP_ALREADY_DELEGATED)
  }
}
