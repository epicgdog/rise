  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module dubhe::asset_pool {

  use sui::bcs::{to_bytes};

  use std::ascii::{string, String, into_bytes};

  use dubhe::table_id;

  use dubhe::dapp_service::{Self, DappHub};

  use dubhe::dapp_system;

  use dubhe::dapp_key;

  use dubhe::dapp_key::DappKey;

  const TABLE_NAME: vector<u8> = b"asset_pool";

  const TABLE_TYPE: vector<u8> = b"Resource";

  const OFFCHAIN: bool = false;

  public struct AssetPool has copy, drop, store {
    pool_address: address,
    lp_asset: address,
    reserve0: u128,
    reserve1: u128,
    k_last: u256,
  }

  public fun new(pool_address: address, lp_asset: address, reserve0: u128, reserve1: u128, k_last: u256): AssetPool {
    AssetPool {
            pool_address,
            lp_asset,
            reserve0,
            reserve1,
            k_last,
        }
  }

  public fun pool_address(self: &AssetPool): address {
    self.pool_address
  }

  public fun lp_asset(self: &AssetPool): address {
    self.lp_asset
  }

  public fun reserve0(self: &AssetPool): u128 {
    self.reserve0
  }

  public fun reserve1(self: &AssetPool): u128 {
    self.reserve1
  }

  public fun k_last(self: &AssetPool): u256 {
    self.k_last
  }

  public fun update_pool_address(self: &mut AssetPool, pool_address: address) {
    self.pool_address = pool_address
  }

  public fun update_lp_asset(self: &mut AssetPool, lp_asset: address) {
    self.lp_asset = lp_asset
  }

  public fun update_reserve0(self: &mut AssetPool, reserve0: u128) {
    self.reserve0 = reserve0
  }

  public fun update_reserve1(self: &mut AssetPool, reserve1: u128) {
    self.reserve1 = reserve1
  }

  public fun update_k_last(self: &mut AssetPool, k_last: u256) {
    self.k_last = k_last
  }

  public fun get_table_id(): String {
    string(TABLE_NAME)
  }

  public fun get_key_schemas(): vector<String> {
    vector[string(b"address"),
    string(b"address")
    ]
  }

  public fun get_value_schemas(): vector<String> {
    vector[string(b"address"), string(b"address"), string(b"u128"), string(b"u128"),
    string(b"u256")
    ]
  }

  public fun get_key_names(): vector<String> {
    vector[string(b"asset0"),
    string(b"asset1")
    ]
  }

  public fun get_value_names(): vector<String> {
    vector[string(b"pool_address"), string(b"lp_asset"), string(b"reserve0"), string(b"reserve1"),
    string(b"k_last")
    ]
  }

  public(package) fun register_table(dapp_hub: &mut DappHub, ctx: &mut TxContext) {
    let dapp_key = dapp_key::new();
    dapp_service::register_table(
            dapp_hub,
             dapp_key,
            string(TABLE_TYPE),
            get_table_id(), 
            get_key_schemas(), 
            get_key_names(), 
            get_value_schemas(), 
            get_value_names(), 
            OFFCHAIN,
            ctx
        );
  }

  public fun has(dapp_hub: &DappHub, asset0: address, asset1: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public fun ensure_has(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public fun ensure_not_has(dapp_hub: &DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::ensure_not_has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public(package) fun delete(dapp_hub: &mut DappHub, asset0: address, asset1: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    dapp_service::delete_record<DappKey>(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, OFFCHAIN);
  }

  public fun get_pool_address(dapp_hub: &DappHub, asset0: address, asset1: address): address {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 0);
    let mut bsc_type = sui::bcs::new(value);
    let pool_address = sui::bcs::peel_address(&mut bsc_type);
    pool_address
  }

  public(package) fun set_pool_address(
    dapp_hub: &mut DappHub,
    asset0: address,
    asset1: address,
    pool_address: address,
  ) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&pool_address);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 0, value, OFFCHAIN);
  }

  public fun get_lp_asset(dapp_hub: &DappHub, asset0: address, asset1: address): address {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 1);
    let mut bsc_type = sui::bcs::new(value);
    let lp_asset = sui::bcs::peel_address(&mut bsc_type);
    lp_asset
  }

  public(package) fun set_lp_asset(dapp_hub: &mut DappHub, asset0: address, asset1: address, lp_asset: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&lp_asset);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 1, value, OFFCHAIN);
  }

  public fun get_reserve0(dapp_hub: &DappHub, asset0: address, asset1: address): u128 {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 2);
    let mut bsc_type = sui::bcs::new(value);
    let reserve0 = sui::bcs::peel_u128(&mut bsc_type);
    reserve0
  }

  public(package) fun set_reserve0(dapp_hub: &mut DappHub, asset0: address, asset1: address, reserve0: u128) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&reserve0);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 2, value, OFFCHAIN);
  }

  public fun get_reserve1(dapp_hub: &DappHub, asset0: address, asset1: address): u128 {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 3);
    let mut bsc_type = sui::bcs::new(value);
    let reserve1 = sui::bcs::peel_u128(&mut bsc_type);
    reserve1
  }

  public(package) fun set_reserve1(dapp_hub: &mut DappHub, asset0: address, asset1: address, reserve1: u128) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&reserve1);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 3, value, OFFCHAIN);
  }

  public fun get_k_last(dapp_hub: &DappHub, asset0: address, asset1: address): u256 {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 4);
    let mut bsc_type = sui::bcs::new(value);
    let k_last = sui::bcs::peel_u256(&mut bsc_type);
    k_last
  }

  public(package) fun set_k_last(dapp_hub: &mut DappHub, asset0: address, asset1: address, k_last: u256) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value = to_bytes(&k_last);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 4, value, OFFCHAIN);
  }

  public fun get(dapp_hub: &DappHub, asset0: address, asset1: address): (address, address, u128, u128, u256) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value_tuple = dapp_service::get_record<DappKey>(dapp_hub, get_table_id(), key_tuple);
    let mut bsc_type = sui::bcs::new(value_tuple);
    let pool_address = sui::bcs::peel_address(&mut bsc_type);
    let lp_asset = sui::bcs::peel_address(&mut bsc_type);
    let reserve0 = sui::bcs::peel_u128(&mut bsc_type);
    let reserve1 = sui::bcs::peel_u128(&mut bsc_type);
    let k_last = sui::bcs::peel_u256(&mut bsc_type);
    (pool_address, lp_asset, reserve0, reserve1, k_last)
  }

  public(package) fun set(
    dapp_hub: &mut DappHub,
    asset0: address,
    asset1: address,
    pool_address: address,
    lp_asset: address,
    reserve0: u128,
    reserve1: u128,
    k_last: u256,
  ) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value_tuple = encode(pool_address, lp_asset, reserve0, reserve1, k_last);
    dapp_service::set_record(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, value_tuple, OFFCHAIN);
  }

  public fun get_struct(dapp_hub: &DappHub, asset0: address, asset1: address): AssetPool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value_tuple = dapp_service::get_record<DappKey>(dapp_hub, get_table_id(), key_tuple);
    decode(value_tuple)
  }

  public(package) fun set_struct(dapp_hub: &mut DappHub, asset0: address, asset1: address, asset_pool: AssetPool) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset0));
    key_tuple.push_back(to_bytes(&asset1));
    let value_tuple = encode_struct(asset_pool);
    dapp_service::set_record(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, value_tuple, OFFCHAIN);
  }

  public fun encode(
    pool_address: address,
    lp_asset: address,
    reserve0: u128,
    reserve1: u128,
    k_last: u256,
  ): vector<vector<u8>> {
    let mut value_tuple = vector::empty();
    value_tuple.push_back(to_bytes(&pool_address));
    value_tuple.push_back(to_bytes(&lp_asset));
    value_tuple.push_back(to_bytes(&reserve0));
    value_tuple.push_back(to_bytes(&reserve1));
    value_tuple.push_back(to_bytes(&k_last));
    value_tuple
  }

  public fun encode_struct(asset_pool: AssetPool): vector<vector<u8>> {
    encode(asset_pool.pool_address, asset_pool.lp_asset, asset_pool.reserve0, asset_pool.reserve1, asset_pool.k_last)
  }

  public fun decode(data: vector<u8>): AssetPool {
    let mut bsc_type = sui::bcs::new(data);
    let pool_address = sui::bcs::peel_address(&mut bsc_type);
    let lp_asset = sui::bcs::peel_address(&mut bsc_type);
    let reserve0 = sui::bcs::peel_u128(&mut bsc_type);
    let reserve1 = sui::bcs::peel_u128(&mut bsc_type);
    let k_last = sui::bcs::peel_u256(&mut bsc_type);
    AssetPool {
            pool_address,
            lp_asset,
            reserve0,
            reserve1,
            k_last,
        }
  }
}
