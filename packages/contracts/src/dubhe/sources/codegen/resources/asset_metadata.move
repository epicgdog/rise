  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module dubhe::asset_metadata {

  use sui::bcs::{to_bytes};

  use std::ascii::{string, String, into_bytes};

  use dubhe::table_id;

  use dubhe::dapp_service::{Self, DappHub};

  use dubhe::dapp_system;

  use dubhe::dapp_key;

  use dubhe::dapp_key::DappKey;

  use dubhe::asset_status;

  use dubhe::asset_status::{AssetStatus};

  use dubhe::asset_type;

  use dubhe::asset_type::{AssetType};

  const TABLE_NAME: vector<u8> = b"asset_metadata";

  const TABLE_TYPE: vector<u8> = b"Resource";

  const OFFCHAIN: bool = false;

  public struct AssetMetadata has copy, drop, store {
    name: String,
    symbol: String,
    description: String,
    decimals: u8,
    icon_url: String,
    owner: address,
    status: AssetStatus,
    is_mintable: bool,
    is_burnable: bool,
    is_freezable: bool,
    asset_type: AssetType,
  }

  public fun new(
    name: String,
    symbol: String,
    description: String,
    decimals: u8,
    icon_url: String,
    owner: address,
    status: AssetStatus,
    is_mintable: bool,
    is_burnable: bool,
    is_freezable: bool,
    asset_type: AssetType,
  ): AssetMetadata {
    AssetMetadata {
            name,
            symbol,
            description,
            decimals,
            icon_url,
            owner,
            status,
            is_mintable,
            is_burnable,
            is_freezable,
            asset_type,
        }
  }

  public fun name(self: &AssetMetadata): String {
    self.name
  }

  public fun symbol(self: &AssetMetadata): String {
    self.symbol
  }

  public fun description(self: &AssetMetadata): String {
    self.description
  }

  public fun decimals(self: &AssetMetadata): u8 {
    self.decimals
  }

  public fun icon_url(self: &AssetMetadata): String {
    self.icon_url
  }

  public fun owner(self: &AssetMetadata): address {
    self.owner
  }

  public fun status(self: &AssetMetadata): AssetStatus {
    self.status
  }

  public fun is_mintable(self: &AssetMetadata): bool {
    self.is_mintable
  }

  public fun is_burnable(self: &AssetMetadata): bool {
    self.is_burnable
  }

  public fun is_freezable(self: &AssetMetadata): bool {
    self.is_freezable
  }

  public fun asset_type(self: &AssetMetadata): AssetType {
    self.asset_type
  }

  public fun update_name(self: &mut AssetMetadata, name: String) {
    self.name = name
  }

  public fun update_symbol(self: &mut AssetMetadata, symbol: String) {
    self.symbol = symbol
  }

  public fun update_description(self: &mut AssetMetadata, description: String) {
    self.description = description
  }

  public fun update_decimals(self: &mut AssetMetadata, decimals: u8) {
    self.decimals = decimals
  }

  public fun update_icon_url(self: &mut AssetMetadata, icon_url: String) {
    self.icon_url = icon_url
  }

  public fun update_owner(self: &mut AssetMetadata, owner: address) {
    self.owner = owner
  }

  public fun update_status(self: &mut AssetMetadata, status: AssetStatus) {
    self.status = status
  }

  public fun update_is_mintable(self: &mut AssetMetadata, is_mintable: bool) {
    self.is_mintable = is_mintable
  }

  public fun update_is_burnable(self: &mut AssetMetadata, is_burnable: bool) {
    self.is_burnable = is_burnable
  }

  public fun update_is_freezable(self: &mut AssetMetadata, is_freezable: bool) {
    self.is_freezable = is_freezable
  }

  public fun update_asset_type(self: &mut AssetMetadata, asset_type: AssetType) {
    self.asset_type = asset_type
  }

  public fun get_table_id(): String {
    string(TABLE_NAME)
  }

  public fun get_key_schemas(): vector<String> {
    vector[
    string(b"address")
    ]
  }

  public fun get_value_schemas(): vector<String> {
    vector[string(b"String"), string(b"String"), string(b"String"), string(b"u8"), string(b"String"), string(b"address"), string(b"AssetStatus"), string(b"bool"), string(b"bool"), string(b"bool"),
    string(b"AssetType")
    ]
  }

  public fun get_key_names(): vector<String> {
    vector[
    string(b"asset_id")
    ]
  }

  public fun get_value_names(): vector<String> {
    vector[string(b"name"), string(b"symbol"), string(b"description"), string(b"decimals"), string(b"icon_url"), string(b"owner"), string(b"status"), string(b"is_mintable"), string(b"is_burnable"), string(b"is_freezable"),
    string(b"asset_type")
    ]
  }

  public(package) fun register_table(dapp_hub: &mut DappHub, ctx: &mut TxContext) {
    let dapp_key = dapp_key::new();
    dapp_service::register_table(
            dapp_hub,
             dapp_key,
            string(TABLE_TYPE),
            get_table_id(), 
            get_key_schemas(), 
            get_key_names(), 
            get_value_schemas(), 
            get_value_names(), 
            OFFCHAIN,
            ctx
        );
  }

  public fun has(dapp_hub: &DappHub, asset_id: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    dapp_service::has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public fun ensure_has(dapp_hub: &DappHub, asset_id: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    dapp_service::ensure_has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public fun ensure_not_has(dapp_hub: &DappHub, asset_id: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    dapp_service::ensure_not_has_record<DappKey>(dapp_hub, get_table_id(), key_tuple)
  }

  public(package) fun delete(dapp_hub: &mut DappHub, asset_id: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    dapp_service::delete_record<DappKey>(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, OFFCHAIN);
  }

  public fun get_name(dapp_hub: &DappHub, asset_id: address): String {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 0);
    let mut bsc_type = sui::bcs::new(value);
    let name = dubhe::bcs::peel_string(&mut bsc_type);
    name
  }

  public(package) fun set_name(dapp_hub: &mut DappHub, asset_id: address, name: String) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&into_bytes(name));
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 0, value, OFFCHAIN);
  }

  public fun get_symbol(dapp_hub: &DappHub, asset_id: address): String {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 1);
    let mut bsc_type = sui::bcs::new(value);
    let symbol = dubhe::bcs::peel_string(&mut bsc_type);
    symbol
  }

  public(package) fun set_symbol(dapp_hub: &mut DappHub, asset_id: address, symbol: String) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&into_bytes(symbol));
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 1, value, OFFCHAIN);
  }

  public fun get_description(dapp_hub: &DappHub, asset_id: address): String {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 2);
    let mut bsc_type = sui::bcs::new(value);
    let description = dubhe::bcs::peel_string(&mut bsc_type);
    description
  }

  public(package) fun set_description(dapp_hub: &mut DappHub, asset_id: address, description: String) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&into_bytes(description));
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 2, value, OFFCHAIN);
  }

  public fun get_decimals(dapp_hub: &DappHub, asset_id: address): u8 {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 3);
    let mut bsc_type = sui::bcs::new(value);
    let decimals = sui::bcs::peel_u8(&mut bsc_type);
    decimals
  }

  public(package) fun set_decimals(dapp_hub: &mut DappHub, asset_id: address, decimals: u8) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&decimals);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 3, value, OFFCHAIN);
  }

  public fun get_icon_url(dapp_hub: &DappHub, asset_id: address): String {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 4);
    let mut bsc_type = sui::bcs::new(value);
    let icon_url = dubhe::bcs::peel_string(&mut bsc_type);
    icon_url
  }

  public(package) fun set_icon_url(dapp_hub: &mut DappHub, asset_id: address, icon_url: String) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&into_bytes(icon_url));
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 4, value, OFFCHAIN);
  }

  public fun get_owner(dapp_hub: &DappHub, asset_id: address): address {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 5);
    let mut bsc_type = sui::bcs::new(value);
    let owner = sui::bcs::peel_address(&mut bsc_type);
    owner
  }

  public(package) fun set_owner(dapp_hub: &mut DappHub, asset_id: address, owner: address) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&owner);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 5, value, OFFCHAIN);
  }

  public fun get_status(dapp_hub: &DappHub, asset_id: address): AssetStatus {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 6);
    let mut bsc_type = sui::bcs::new(value);
    let status = dubhe::asset_status::decode(&mut bsc_type);
    status
  }

  public(package) fun set_status(dapp_hub: &mut DappHub, asset_id: address, status: AssetStatus) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dubhe::asset_status::encode(status);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 6, value, OFFCHAIN);
  }

  public fun get_is_mintable(dapp_hub: &DappHub, asset_id: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 7);
    let mut bsc_type = sui::bcs::new(value);
    let is_mintable = sui::bcs::peel_bool(&mut bsc_type);
    is_mintable
  }

  public(package) fun set_is_mintable(dapp_hub: &mut DappHub, asset_id: address, is_mintable: bool) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&is_mintable);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 7, value, OFFCHAIN);
  }

  public fun get_is_burnable(dapp_hub: &DappHub, asset_id: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 8);
    let mut bsc_type = sui::bcs::new(value);
    let is_burnable = sui::bcs::peel_bool(&mut bsc_type);
    is_burnable
  }

  public(package) fun set_is_burnable(dapp_hub: &mut DappHub, asset_id: address, is_burnable: bool) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&is_burnable);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 8, value, OFFCHAIN);
  }

  public fun get_is_freezable(dapp_hub: &DappHub, asset_id: address): bool {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 9);
    let mut bsc_type = sui::bcs::new(value);
    let is_freezable = sui::bcs::peel_bool(&mut bsc_type);
    is_freezable
  }

  public(package) fun set_is_freezable(dapp_hub: &mut DappHub, asset_id: address, is_freezable: bool) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = to_bytes(&is_freezable);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 9, value, OFFCHAIN);
  }

  public fun get_asset_type(dapp_hub: &DappHub, asset_id: address): AssetType {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dapp_service::get_field<DappKey>(dapp_hub, get_table_id(), key_tuple, 10);
    let mut bsc_type = sui::bcs::new(value);
    let asset_type = dubhe::asset_type::decode(&mut bsc_type);
    asset_type
  }

  public(package) fun set_asset_type(dapp_hub: &mut DappHub, asset_id: address, asset_type: AssetType) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value = dubhe::asset_type::encode(asset_type);
    dapp_service::set_field(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, 10, value, OFFCHAIN);
  }

  public fun get(
    dapp_hub: &DappHub,
    asset_id: address,
  ): (String, String, String, u8, String, address, AssetStatus, bool, bool, bool, AssetType) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value_tuple = dapp_service::get_record<DappKey>(dapp_hub, get_table_id(), key_tuple);
    let mut bsc_type = sui::bcs::new(value_tuple);
    let name = dubhe::bcs::peel_string(&mut bsc_type);
    let symbol = dubhe::bcs::peel_string(&mut bsc_type);
    let description = dubhe::bcs::peel_string(&mut bsc_type);
    let decimals = sui::bcs::peel_u8(&mut bsc_type);
    let icon_url = dubhe::bcs::peel_string(&mut bsc_type);
    let owner = sui::bcs::peel_address(&mut bsc_type);
    let status = dubhe::asset_status::decode(&mut bsc_type);
    let is_mintable = sui::bcs::peel_bool(&mut bsc_type);
    let is_burnable = sui::bcs::peel_bool(&mut bsc_type);
    let is_freezable = sui::bcs::peel_bool(&mut bsc_type);
    let asset_type = dubhe::asset_type::decode(&mut bsc_type);
    (name, symbol, description, decimals, icon_url, owner, status, is_mintable, is_burnable, is_freezable, asset_type)
  }

  public(package) fun set(
    dapp_hub: &mut DappHub,
    asset_id: address,
    name: String,
    symbol: String,
    description: String,
    decimals: u8,
    icon_url: String,
    owner: address,
    status: AssetStatus,
    is_mintable: bool,
    is_burnable: bool,
    is_freezable: bool,
    asset_type: AssetType,
  ) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value_tuple = encode(name, symbol, description, decimals, icon_url, owner, status, is_mintable, is_burnable, is_freezable, asset_type);
    dapp_service::set_record(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, value_tuple, OFFCHAIN);
  }

  public fun get_struct(dapp_hub: &DappHub, asset_id: address): AssetMetadata {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value_tuple = dapp_service::get_record<DappKey>(dapp_hub, get_table_id(), key_tuple);
    decode(value_tuple)
  }

  public(package) fun set_struct(dapp_hub: &mut DappHub, asset_id: address, asset_metadata: AssetMetadata) {
    let mut key_tuple = vector::empty();
    key_tuple.push_back(to_bytes(&asset_id));
    let value_tuple = encode_struct(asset_metadata);
    dapp_service::set_record(dapp_hub, dapp_key::new(), get_table_id(), key_tuple, value_tuple, OFFCHAIN);
  }

  public fun encode(
    name: String,
    symbol: String,
    description: String,
    decimals: u8,
    icon_url: String,
    owner: address,
    status: AssetStatus,
    is_mintable: bool,
    is_burnable: bool,
    is_freezable: bool,
    asset_type: AssetType,
  ): vector<vector<u8>> {
    let mut value_tuple = vector::empty();
    value_tuple.push_back(to_bytes(&into_bytes(name)));
    value_tuple.push_back(to_bytes(&into_bytes(symbol)));
    value_tuple.push_back(to_bytes(&into_bytes(description)));
    value_tuple.push_back(to_bytes(&decimals));
    value_tuple.push_back(to_bytes(&into_bytes(icon_url)));
    value_tuple.push_back(to_bytes(&owner));
    value_tuple.push_back(dubhe::asset_status::encode(status));
    value_tuple.push_back(to_bytes(&is_mintable));
    value_tuple.push_back(to_bytes(&is_burnable));
    value_tuple.push_back(to_bytes(&is_freezable));
    value_tuple.push_back(dubhe::asset_type::encode(asset_type));
    value_tuple
  }

  public fun encode_struct(asset_metadata: AssetMetadata): vector<vector<u8>> {
    encode(asset_metadata.name, asset_metadata.symbol, asset_metadata.description, asset_metadata.decimals, asset_metadata.icon_url, asset_metadata.owner, asset_metadata.status, asset_metadata.is_mintable, asset_metadata.is_burnable, asset_metadata.is_freezable, asset_metadata.asset_type)
  }

  public fun decode(data: vector<u8>): AssetMetadata {
    let mut bsc_type = sui::bcs::new(data);
    let name = string(sui::bcs::peel_vec_u8(&mut bsc_type));
    let symbol = string(sui::bcs::peel_vec_u8(&mut bsc_type));
    let description = string(sui::bcs::peel_vec_u8(&mut bsc_type));
    let decimals = sui::bcs::peel_u8(&mut bsc_type);
    let icon_url = string(sui::bcs::peel_vec_u8(&mut bsc_type));
    let owner = sui::bcs::peel_address(&mut bsc_type);
    let status = dubhe::asset_status::decode(&mut bsc_type);
    let is_mintable = sui::bcs::peel_bool(&mut bsc_type);
    let is_burnable = sui::bcs::peel_bool(&mut bsc_type);
    let is_freezable = sui::bcs::peel_bool(&mut bsc_type);
    let asset_type = dubhe::asset_type::decode(&mut bsc_type);
    AssetMetadata {
            name,
            symbol,
            description,
            decimals,
            icon_url,
            owner,
            status,
            is_mintable,
            is_burnable,
            is_freezable,
            asset_type,
        }
  }
}
